from .models import Sudoku4x4
from .symmetry import generate_180_symmetric_sudokus

fn apply_digit_mapping(grid: Sudoku4x4, mapping: SIMD[DType.int8, 8]) -> Sudoku4x4:
  """Apply a digit relabeling to a grid"""
  # mapping[i] tells us what digit i maps to (index 0 unused)
  var new_values = SIMD[DType.int8, 16](0)
  
  for i in range(16):
    var old_digit = Int(grid.grid[i])
    if old_digit > 0:
      new_values[i] = mapping[old_digit]
  
  return Sudoku4x4(new_values)

fn grid_to_canonical_form(grid: Sudoku4x4) -> Sudoku4x4:
  """Find the lexicographically smallest relabeling of this grid"""
  var best_grid = grid
  var best_value = grid_to_int(grid)
  
  # Generate all 24 permutations of digits 1-4
  # We'll do this systematically
  var perms = List[SIMD[DType.int8, 8]]()
  
  # All 24 permutations of [1,2,3,4]
  perms.append(SIMD[DType.int8, 8](0, 1, 2, 3, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 1, 2, 4, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 1, 3, 2, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 1, 3, 4, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 1, 4, 2, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 1, 4, 3, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 1, 3, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 1, 4, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 3, 1, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 3, 4, 1, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 4, 1, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 2, 4, 3, 1, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 1, 2, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 1, 4, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 2, 1, 4, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 2, 4, 1, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 4, 1, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 3, 4, 2, 1, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 1, 2, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 1, 3, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 2, 1, 3, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 2, 3, 1, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 3, 1, 2, 0, 0, 0))
  perms.append(SIMD[DType.int8, 8](0, 4, 3, 2, 1, 0, 0, 0))
  
  for perm in perms:
    var relabeled = apply_digit_mapping(grid, perm)
    var value = grid_to_int(relabeled)
    
    if value < best_value:
      best_value = value
      best_grid = relabeled
  
  return best_grid

fn grid_to_int(grid: Sudoku4x4) -> Int:
  """Convert grid to integer for comparison"""
  var result = 0
  for i in range(16):
    result = result * 10 + Int(grid.grid[i])
  return result

fn grids_equal(g1: Sudoku4x4, g2: Sudoku4x4) -> Bool:
  """Check if two grids are identical"""
  for i in range(16):
    if g1.grid[i] != g2.grid[i]:
      return False
  return True

fn count_distinct_patterns() -> Int:
  """Count distinct patterns among 180° symmetric grids"""
  print("\n=== COUNTING DISTINCT PATTERNS ===")
  
  # Generate all 180° symmetric grids
  var symmetric_grids = generate_180_symmetric_sudokus()
  print("Total 180° symmetric grids: ", len(symmetric_grids))
  
  # Find canonical forms
  var canonical_grids = List[Sudoku4x4]()
  
  for grid in symmetric_grids:
    var canonical = grid_to_canonical_form(grid)
    
    # Check if we've seen this canonical form before
    var is_new = True
    for existing in canonical_grids:
      if grids_equal(canonical, existing):
        is_new = False
        break
    
    if is_new:
      canonical_grids.append(canonical)
      print("\nFound new pattern #", len(canonical_grids), ":")
      canonical.print_grid()
  
  return len(canonical_grids)

fn demonstrate_equivalence():
  """Show an example of grids that are equivalent under relabeling"""
  print("\n=== DEMONSTRATING EQUIVALENCE ===")
  
  # Create two grids that differ only by relabeling
  var values1 = SIMD[DType.int8, 16](
    1, 2, 3, 4,
    3, 4, 1, 2,
    2, 1, 4, 3,
    4, 3, 2, 1
  )
  
  var values2 = SIMD[DType.int8, 16](
    2, 1, 4, 3,
    4, 3, 2, 1,
    1, 2, 3, 4,
    3, 4, 1, 2
  )
  
  var grid1 = Sudoku4x4(values1)
  var grid2 = Sudoku4x4(values2)
  
  print("Grid 1:")
  grid1.print_grid()
  
  print("Grid 2 (relabeling of Grid 1 with 1↔2, 3↔4):")
  grid2.print_grid()
  
  print("Canonical form of Grid 1:")
  var canon1 = grid_to_canonical_form(grid1)
  canon1.print_grid()
  
  print("Canonical form of Grid 2:")
  var canon2 = grid_to_canonical_form(grid2)
  canon2.print_grid()
  
  if grids_equal(canon1, canon2):
    print("✓ These grids have the same canonical form - they represent the same pattern!")
  else:
    print("✗ These grids have different canonical forms")

